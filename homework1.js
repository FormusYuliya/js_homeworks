/* 
Приклад:    'number' + 3 + 3
Результат:   'number33'
Пояснення:   Оскільки переше значення в нас типу String, то усі начтупні числа будуть приведені до його типу та відпудиться конкатинація усіх строк в один String
*/

/* 
Приклад:     null + 3
Результат:   3
Пояснення:   Оскільки null за своєю природою позначає на відсутність значення, то "умовне ніщо", він же 0 + 3 дасть в результаті число 3
*/

/* 
Приклад:     5 && "qwerty"
Результат:   'qwerty'
Пояснення:   Оскілки обидва оператори не є нулем або NaN, то операція логічного множення є істинно, і повернається останне значення.  
*/

/* 
Приклад:     +'40' + +'2' + "hillel"
Результат:   '42hillel'
Пояснення:   Оскільки перед числами 40 і 2 є додатковий унарний плюс, вони приводятся до числового типу і складаються. Далі число 42 конкатинується з рядком hillel
*/

/* 
Приклад:     '10' - 5 === 6;
Результат:   false
Пояснення:   У першій частині виразу відбувається математична операція 10-5, яка дає в результаті 5. При порівнянні 5 та 6, ми отримуємо false бо числа не однакові
*/

/* 
Приклад:     true + false
Результат:   1
Пояснення:   Оскільки JS завжди намагається привести все до числа, то вираз буде приведений до наступного типу 1+0, що в результаті дає 1
*/

/* 
Приклад:     '4px' - 3
Результат:   NaN
Пояснення:   Результатом буде NaN(Not a Number), тому що неможливо конвертувати '4px' у число, бо це значення має додаткові букви
*/

/* 
Приклад:     '4' - 3
Результат:   1
Пояснення:   Коли Js, бачить знак - він автоматично намагається привести обидва значення до числа і виконати операцію 4-3=1
*/

/* 
Приклад:     '6' + 3 ** 0;
Результат:   '61'
Пояснення:   Оскільки перед значенням '6' немає унарного +, то значення рахується як стрінга і конкатинується з виразом (3**0). Знак ** піднімає 3йку в 0 степіть, що в свою чергу дає 1цю.
             І як результат ми конкатинуємо стрінгу '6' з 1 в string '61'
*/

/* 
Приклад:     12 / '6'
Результат:   2
Пояснення:   В JS знаки ділення та множення працюють тільки к числами, тому в результатом буде число 2  
*/

/* 
Приклад:     '10' + (5 === 6);
Результат:   '10false'
Пояснення:   Результатом строгого порівняння чисел  5 і 6 буде false, бо вони не однакові. А оскільки перший операнд '10' типу String, то відбувається конкатенацію рядків
*/

/* 
Приклад:     null == ''
Результат:   false
Пояснення:   Значення '' належить до типу String, хоч і пуста в середині. Принаймні в Java вона малаб посилання на обєкт типу String. А тип Null не має посилання на об'єкт.
             Хоча ймовірно є краще пояснення, бо тут моя думка грунтується здогадках від отриманого результату та паралелі з іншою мовою програмування.
*/

/* 
Приклад:     3 ** (9 / 3);
Результат:   27
Пояснення:   Результат буде автоматично приведений до числового типу 3 в кубі = 27
*/

/* 
Приклад:     !!'false' == !!'true'
Результат:   true
Пояснення:   Не розумію чому такий результат :( 
*/

/* 
Приклад:     0 || '0' && 1
Результат:   1
Пояснення:   Першою виконується дія логічного множення '0' && 1. Так як стрінг '0', не пустий, NAN  чи 0 - ми вважаємо що він truthy, а 1 в свою чергу також truthy - результатом буде 2ге значення з виразу.
             При виконання другої операції 0 || 1 - Значення 0 сприймається як falsy. Тож у виразі falsy || truly -буде повернуте перше правдиве значення 1
*/



/* 
Приклад:     (+null == false) < 1;
Результат:   false
Пояснення:   Першою виконується дія в дужках, де +null приводиться до числа 0, через наявність унарного + перед словом. Далі порівнюємо 0 та false, вираз є truе.
             Далі відбувається порівняння truе < 1, де truе автоматично приводиться до числового типу і маємо вираз -  1 < 1, який є хибним.
*/


/* 
Приклад:     false && true || true
Результат:   true
Пояснення:   Першою виконується множення false && true, яка повертає false. Потім виконується дія логічного додавання false || true - яка є істинною
*/

/* 
Приклад:     false && (false || true);
Результат:   false
Пояснення:   Спокачтку виконуэться дія логічного додавання в дужках false || true, яка повертає результат true.
             Після чого відбувається наступна дія логічного множення false && true, яка повертає результат false
*/

/* 
Приклад:     (+null == false) < 1 ** 5;
Результат:   false
Пояснення:   Спокачтку виконуэться дія порівняння в дужках (+null == false), де +null - це 0, а false автоматично приводится до числа - 0. При порівнянні 0==0 отримуємо результат true.
             Потім виконується дія введення у 1 у 5й степені 1 ** 5, результатом якої буде 1.
             При порівнянні true < 1, перший операнд приводиться до числа 1 і виконується порівняння 1 < 1 результат false
*/


